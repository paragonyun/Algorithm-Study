'''
N x M 크기의 얼음 틀이 있다. 
구멍이 뚫려있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다.

상하좌우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 
이때 얼음 틀의 모양이 주어졌을 때 생성되는 
총 아이스크림의 개수를 구하는 프로그램을 작성하시오

입력 예시
4 5
00110
00011
11111
00000

출력 : 3

입력 예시
15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111

출력 : 8

제한 시간
30분

'''

## 시작 시간 : 11:50
## 종료 시간 : 실패

# n, m = map(int, input().split())

# graph = []
# for i in range(n) :
#     graph.append(list(map(int, input())))


# visited = [[False]*m for i in range(n)]


# def dfs(graph, x,y, visited) :
#     visited[x][y] = True #현재 위치 방문 처리


# 교재의 풀이
'''
해당 문제는 연결 요소 찾기(Connected Component)찾기 문제임!!
DFS나 BFS로 해결 가능 얼음판이 어차피 그래프 모양으로 표현할 수 있기 때문
(인접한 노드이기 때문에)

방문처리를 어떻게 할 것인가를 잘 생각했어야 하는 문제

[DFS]
1. 어떤 지점의 상하좌우 모두 살펴보고 0이면서 아직 방문하지 않은 노드면 방문
2. 방문한 곳에서 다시 상하좌우 모두 보고 위의 과정을 반복
'''    
n, m = map(int, input().split())
graph = []
for i in range(n) :
    graph.append(list(map(int, input()))) # 여기까진 똑같음 다만 dfs 함수를 미리 정의!

def dfs(x, y) :
    if x <= -1 or x>= n or y <= -1 or y >= m : # 범위를 벗어나면
        return False # 종료
    
    # 아직 방문하지 않은 경우
    if graph[x][y] == 0 :
        graph[x][y] == 1 # 방문했다고 하고 (근데 스택이나 큐를 안 쓰네?)
        dfs(x-1, y) # 상 
        dfs(x, y-1) # 좌
        dfs(x+1, y) # 하
        dfs(x, y+1) # 후
        '''
        상하좌우에 사용된 dfs()함수는 return 값을 사용하지 않음
        -> 연결된 모든 노드에 대해 방문 처리를 하기 위함 
        => 즉, 연결된 모든 노드를 다 방문처리 가능함!!! 
        아.. 이렇게 연결된 모든 요소를 다 뽑아내는구나..
        '''

        return True # 현재 위치에서 처음 dfs가 True로 나옴 -> 아래 코드이 result 값 증가
    
    return False


result = 0 
for i in range(n) :
    for j in range(m) :
        if dfs(i, j) == True :
            result += 1

print(result)